note https://docs.python.org/3/library/re.html
# python中的RE表达式
    python中搜索Unicode和byte一样出色，但是不能将二者混杂在一起搜索：你不能在Unicode中查找一个byte字符，反之亦然，且替换操作也是这样的。
    正则表达式使用反斜杠'\'来表示特殊含义，或将一些特殊字符转化为普通字符。在python中要注意如果你要查找'\\'则表达式为'\\\\'，因为python中每个反斜杠已经用'\\'来表示了。如果使用'\'转译了一个无效的字符，会有DeprecationWarning警告，后面的版本可能会改成SyntacxError。避免上述情况可以在字符串引号外前加'r',这样r'\n'便会被认为包含'\'和'n'两个字符。

# 语法
    正则表达式可拼接，即A和B都是RE，那么AB也是RE。通常，如果p匹配A，q匹配B，那么pq可以匹配AB，除非A或B包含低优先级操作，A和B存在边界，或有命名组引用。
    绝大多数普通字符比如'a','A','0'他们本身就是正则表达式，匹配自身，且'aA0'将匹配'aA0'，另一些特殊的表达式如(,|使用时不需要像普通字符串一样用引号包含，
    重复修饰符如* + ? {m,n}等不能直接嵌套使用，这样避免非贪婪后缀符?的作用域混淆???,如(?:a{6})*匹配多组6个'a'字符。
## .
    默认模式下匹配任何没有新行的字符，如果有DOTALL标志，新行也会包含进来。
## ^ 
    指定匹配字符的开头，在MULTILINE模式下每遇到新行便会立即返回结果
## $ 
    指定匹配字符的结尾，或者是在新行前的字符结尾，???MULTILINE模式下匹配换行前的一个字符。比如字符串'foo1\nfoo2\n'普通模式使用foo.$会匹配foo2，多行模式下会匹配foo1。用单个$在'foo\n'中会有两个空匹配,一个是新行前的东西，另一个是字符结尾。
## *
    匹配零或更多个在其左侧字符。如ab*会匹配'a','ab'或者'a'后面跟很多'b'的字符
## +
    匹配一个或更多个在其左侧字符。如ab+会匹配'a'后面跟着至少一个'b'的字符，所以不会匹配单个'a'
## ?
    匹配零或一个在其左侧字符
## *? +? ??
    * + ?这三个修饰词都是贪婪型的，它们会尽可能找到更多的匹配项，在其右侧加上?使得其变为非贪婪型，比如使用<.*?>匹配'<a>b<c>'只会得到'<a>'而没有'<c>'
## {m}
    指定左侧字符具有m项重复，例如a{6}会匹配6个'a'，而不会匹配5个'a'
## {m,n}
    指定左侧字符具有m至n项重复，会优先匹配到更多的重复项。如k{1,3}会优先匹配3个'k'。忽略m默认下限为0，忽略n默认上限为无穷。','不应被忽略，否则会迷茫
## {m,n}?
    非贪婪型的{m,n}，会优先匹配到更少的重复项。
## \
    用来转译一些RE中的特殊字符，如'\*'会被当作搜索单个'*'字符。或者标识右侧将会有特殊序列
    如果你没用r'raw'样式搜索，那么请牢记python也使用'\'来转译字符，当某个转译不被python识别时它才能为你所用，否则就得使用'\\'，所以推荐还是用r' '
## []
    表示一些字符的合集。如[amk]会匹配'a','m',k'
    通过加'-'可以表示一定范围的字符。如[a-z]匹配所有小写ASCII字母，[0-5][0-9]匹配从00到59的两位数字，[0-9A-Fa-f]匹配单个字符的十六进制数字。如果'-'被转译或者'-'作为首个或末尾的字符，都将视为普通字符。如[-a]和[a\-Z]
    RE中的特殊字符在[]中视为普通字符
    可以在[]中使用\w \S，具体匹配模式由ASCII或者LOCALE模式决定
    没有使用'-'限定范围的字符，都作为集合的补充字符使用。
    如果集合的第一个字符是'^'，所有不在集合内的字符将被匹配。[^^]将会匹配除了'^'的所有字符
    如果要匹配'['or']'，要么其在集合的首个字符，要么加转译字符
    新Unicode技术标准中将允许集合嵌套和操作。为了能适应这种新特性将会对语法作出的改变，将对以'['为首字符的集合或者'--' '&&' '~~' '||'的使用作出警告，避免这些警告请使用转译字符
    另外FutureWarning的发出表示当前使用方法将会和未来新特性冲突
## ｜
    A和B是RE的判断式，A|B将匹配A或者B。多个RE判断式可以用'|'分割。这样的用法在组里一样有效。在搜索目标字符时，表达式从'|'左侧向右侧顺序匹配，左侧若匹配成功右侧将不会再测试，称它为非贪婪型也算。通过转译或者将它放在集合中来匹配它的普通字符,'\','[|]
## (...)[https://docs.python.org/zh-cn/3/library/re.html#index-14]
    匹配括号中的表达式，指定组的开始与结尾???组的内容可以在匹配后再确定，????。如要匹配'('or')'使用转译或者包含于集合中
## (?...)
    ?后的字符决定语法和结构。
## (?aiLmsux)
    以上flag当中可以使用一个或多个，使你不必向re.compile()中传入参数便能使用这些flag
    re.A 仅匹配ASCII，re.I 忽略大小写，re.L 由地域决定，re.M 多行模式，re.S 点dot匹配全部，re.U Unicode匹配 ，re.X 详细信息
## (?:...)
    括号表达式的非捕获版本，组的内容不能匹配后再确定????
## (?aiLmsux-imsx:...)
    零或多个flag用'-'衔接可选的一个或多个flag，字母表示移除或者设置相关的flag。
    'a' 'L' 'u'在用做内联flag时相互排斥，所以不能结合或者跟随'-'。当其中一项出现在内联组中时便覆盖了这个括号组内的匹配模式。例如，在Unicode中(?a:...)将切换为只匹配ASCII，(?u:...)切换为Unicode匹配(默认)。在byte中(?L:...)切换为当地语言，(?a:...)切换为ASCII
    3.7版本中以上三个排斥的flag可以用在同一组合内。
## (?P<name>...)
    与括号中的正则表达式类似，但是匹配到的子字符串是通过符号组名来访问的，组名必须是有效的python标识符，一个RE式中的组名必须只定义一次，一个符号组同时也是数字组，就像没有组名一样
    命名组可以通过三种上下文来访问。例如(?P<quote>['"]).*?(?P=quote)将会匹配到带有单引号或双引号的东西
    ????引用方法表
## (?P=name)
    引用名为name组的匹配结果
## (?#...)
    注释信息，会被忽略
## (?=...)
    匹配...中的内容，但不使用其中的内容
## (?!...)
    匹配不是...的内容，例如Isaac(?!Asimov)匹配后面不跟着Asimov的Isaac
## (?<=...)
    如果当前位置的字符的左侧与...匹配，那么匹配当前位置的字符(不包括...)
    例如(?<=abc)def将从'abcdef'匹配到'def'
## (?<!...)
    如果当前位置的字符的左侧与...不匹配，那么匹配当前位置的字符(不包括...)
## (?(id/name)yes-pattern|no-pattern)
    假如给定了一个id或者name已经存在那么匹配yes-pattern，否则no-pattern
    例如(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)，这是个简陋的email匹配字段，他可以匹配包含在尖括号内的或者没有尖括号的邮箱
    <858539305@qq.com>
    lightingyu@gmail.com
    g@g.cn
## \number
    匹配相同id组中的内容。组序号从1开始标注。例如(.+) \1将会匹配到'the the' '55 55'。序号应小于99，当序号为0或者是三位八进制，那么其表示八进制数字值。
    所有数字转译在[]中被视为普通字符
## \A
    匹配项仅在字符串的开头
## \b
    匹配仅在单词的开头或结尾的字符，可以空字符。单词在这里的定义为一连串的字母。
    要注意\b？？？？
## \B
    当不是单词的开头或结尾时匹配空字符。在Unicode中单词是字母数字或者下划线，具体对word的界定要取决于是否使用了ASCII和LOCALE标志。如r'py\B'匹配'python' 'py3'，但不匹配'py' 'py.'
## \d
    对于Unicode字符，匹配任何Unicode十进制数，包括[0-9]还有其他许多数字字符。如果有ASCII标志则仅匹配[0-9]
    对于8-bit(byte)字符，匹配任何在[0-9]中的十进制数
## \D
    与\d相反。
    使用了ASCII标志后等价于[^0-9]
## \s
    对于Unicode字符，匹配空白字符，比如[ \t\n\r\f\v]和其它任何空白的字符。如果ASCII被指定，则仅[ \t\n\r\f\v]
    对于8-bit(byte)字符，匹配[ \t\n\r\f\v]
## \S
    与\s相反，且当ASCII指定时，等价于[^ \t\n\r\f\v]
## \w
    对于Unicode字符，匹配可以构成词语的绝大部分字符，包括数字和下划线，如果指定LOCALE，则使用当地语言的相关字符，如果指定ASCII则同下
    对于8-bit(byte)字符，仅[a-zA-Z0-9_]
## \W
    与\w相反。且当ASCII指定时，等价于[^a-zA-Z0-9_]
## \Z
    仅匹配字符串结尾

# RE中的字符转译  此部分直接复制了中文文档
    绝大部分Python的标准转义字符也被正则表达式分析器支持。:

    \a      \b      \f      \n
    \N      \r      \t      \u
    \U      \v      \x      \\
    （注意 \b 被用于表示词语的边界，它只在字符集合内表示退格，比如 [\b] 。）

    '\u', '\U' 和 '\N' 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。 未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。

    八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。

# 模块内容
    模块定义了一些函数、常量和一个异常。有些函数是RE式方法的简化版，大多正式应用都使用编译后的RE
    3.6版本更新：Flag常量现在也是RegexFlag的一项实例，隶属于enum.IntFlag

## re.compile(patter,flags=0)
    将RE式pattern编译为一个RE对象，可以直接用它的match() search()等方法：
        prog = re.compile(pattern)
        result = prog.match(string)
    等同于：
        result = re.match(pattern, string)
    当需要多次使用时先获取其对象，会更有效率一些
    近几个传入compile()的RE式和模块级匹配函数的已编译版本都会被缓存起来，所以使用RE式不多的程序无需担心编译的问题
    pattern可由flags指定一些特性。
## re.A
## re.ASCII
    使得\w, \W, \b, \B, \d, \D, \s 和 \S 仅做ASCII匹配。当然如果本来就是ASCII的会忽略此标志。相关内联标志(?a)
    要注意反向兼容的问题，re.U标志仍存在，只是这个在python3中有些多余，因为默认就是Unicode
## re.DEBUG
    显示编译表达式的调试信息。没有相关内联标志
## re.I
## re.IGNORECASE
    匹配时忽略大小写。那么[A-Z]也会匹配到[a-z]的内容。Unicode匹配也如此(such as Ü matching ü) 。????。等同于内联标志(?i)
    一些特定情况参考头部文档
## re.L
## re.LOCALE
????